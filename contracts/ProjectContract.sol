// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract ProjectContract is AutomationCompatibleInterface {
    // Project details
    string public title;
    string public description;
    string public deliverables;
    uint256 public startDate;
    uint256 public endDate;
    uint256 public milestoneCounter;
    
    // Milestone payments must be completed before revenue sharing begins
    bool public milestoneIsCompleted;

    struct MilestonePaymentInterval {
        uint256 interval;
        uint256 amount;
    }

    struct RevenuePaymentInterval {
        uint256 interval;
    }
    
    MilestonePaymentInterval public milestonePaymentIntervalObj;
    RevenuePaymentInterval public revenuePaymentIntervalObj;

    // Freelancers involved in project
    address payable[] public freelancers;

    // Revenue Sharing Percentage
    mapping(address => uint256) public revenueShares;

    // Project Designated Multi-Sig Address
    address multiSigAddress;

    // Modifier for only Multi-Sig
    modifier onlyMultiSig {
      require(msg.sender == multiSigAddress);
      _;
    }

    // Constructor to initialize project details
    constructor(
        string memory _title,
        string memory _description,
        string memory _deliverables,
        uint256 _startDate,
        uint256 _endDate,
        address _multiSigAddress
    ) {
        title = _title;
        description = _description;
        deliverables = _deliverables;
        startDate = _startDate;
        endDate = _endDate;
        multiSigAddress = _multiSigAddress;
        milestoneIsCompleted = false;
        milestoneCounter = 0;
    }

    // Project Owner can Deposit Funds that will be used for payment
    function deposit() payable external {
    }

    // Adding Freelancers to the project
    function addFreelancer(address payable _freelancer) public onlyMultiSig {
        freelancers.push(_freelancer);
    }

    // Removing Freelancers from the project
    function removeFreelancer(address _freelancer) public onlyMultiSig {
        for (uint256 i = 0; i < freelancers.length; i++) {
            if (freelancers[i] == _freelancer) {
                freelancers[i] = freelancers[freelancers.length - 1];
                freelancers.pop();
                break;
            }
        }
    }

    // Function to set the percentage value of revenue for a freelancer
    function setRevenueShare(address _freelancer, uint256 _percentage) public onlyMultiSig {
        require(_percentage <= 100, "Percentage value must be less than or equal to 100");
        revenueShares[_freelancer] = _percentage;
    }

    // Adding Payment Intervals
    function addRevenuePaymentInterval(uint256 _interval) public onlyMultiSig {
        revenuePaymentIntervalObj = RevenuePaymentInterval(_interval);
    }

    // Adding Milestone Payment Intervals
    function addMilestonePaymentInterval(
        uint256 _interval,
        uint256 _amount
    ) public onlyMultiSig {
        milestonePaymentIntervalObj = MilestonePaymentInterval(_interval, _amount);
    }

    // Chainlink Automation Functions
    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {   
        if (milestoneIsCompleted) {
            // Revenue Payments
            upkeepNeeded = block.timestamp > revenuePaymentIntervalObj.interval;
        } else {
            // Milestone Payments
            upkeepNeeded = block.timestamp > milestonePaymentIntervalObj.interval;
        }
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if (milestoneIsCompleted && block.timestamp > revenuePaymentIntervalObj.interval) {
            // Revenue Payments
            for (uint256 i = 0; i < freelancers.length; i++) {
                uint256 revenuePayout = revenueShares[freelancers[i]] * address(this).balance; // % rev of freelancer id * amount in smart contract
                freelancers[i].transfer(revenuePayout);
            }
        } else {
            // Milestone Payments
            if (block.timestamp > milestonePaymentIntervalObj.interval) {
                for (uint256 f = 0; f < freelancers.length; f++) {
                    freelancers[f].transfer(milestonePaymentIntervalObj.amount);
                }
            }
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

}